<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Algorithm Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #0f0e17;
            --secondary: #1a1a2e;
            --accent: #7f5af0;
            --accent-light: #b8a1ff;
            --accent-dark: #5e43d3;
            --success: #2cb67d;
            --warning: #f9a828;
            --error: #ff3864;
            --text: #fffffe;
            --text-secondary: #94a1b2;
            --border: rgba(255, 255, 255, 0.1);
            --glass: rgba(30, 41, 59, 0.85);
        }

        [data-theme="light"] {
            --primary: #fffffe;
            --secondary: #f2f4f6;
            --text: #0f0e17;
            --text-secondary: #2e2e3a;
            --glass: rgba(255, 255, 255, 0.85);
            --border: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, #121629 100%);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: background 0.5s ease;
        }

        [data-theme="light"] body {
            background: linear-gradient(135deg, var(--primary) 0%, #e8e8e8 100%);
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 1.5rem;
            padding: 1.5rem;
        }

        .sidebar {
            width: 380px;
            background: var(--glass);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 1.5rem;
            overflow-y: auto;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.1),
                inset 0 1px 1px rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .main-content {
            flex: 5;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .header {
            background: var(--glass);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.1),
                inset 0 1px 1px rgba(255, 255, 255, 0.1);
        }

        .visualization-area {
            flex: 1;
            background: var(--glass);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.1),
                inset 0 1px 1px rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            font-variation-settings: 'wght' 700;
            letter-spacing: -0.025em;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.875rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section-title {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--accent-light);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title svg, label svg {
            width: 16px;
            height: 16px;
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text);
            font-size: 0.875rem;
            transition: all 0.3s ease;
            appearance: none;
        }

        select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23b8a1ff' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 16px;
        }

        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(127, 90, 240, 0.3);
        }

        .slider-container {
            position: relative;
            padding-top: 0.5rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            background: var(--secondary);
            border-radius: 3px;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 10px rgba(127, 90, 240, 0.4);
        }

        .slider-value {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: 600;
            background: var(--secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 8px;
            min-width: 30px;
            text-align: center;
        }

        .btn {
            width: 100%;
            padding: 0.875rem 1rem;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transform-style: preserve-3d;
        }

        .btn svg {
            width: 16px;
            height: 16px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(127, 90, 240, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-3px) rotateX(10deg);
            box-shadow: 0 15px 30px rgba(127, 90, 240, 0.4);
        }

        .btn-primary:active {
            transform: translateY(1px);
        }

        .btn-primary::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        .btn-primary:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }

        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            100% {
                transform: scale(25, 25);
                opacity: 0;
            }
        }

        .btn-secondary {
            background: var(--secondary);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .pseudocode {
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            font-family: 'Menlo', 'Monaco', monospace;
            font-size: 0.75rem;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre;
            tab-size: 2;
        }

        .complexity-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--success) 0%, #1e7d5e 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.875rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .stat-card {
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
            font-variation-settings: 'wght' 700;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        /* Visualization Styles */
        .sorting-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 400px;
            gap: 2px;
            padding: 2rem 0;
            position: relative;
        }

        .bar {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 8px 8px 0 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 4px 15px rgba(127, 90, 240, 0.2);
            transform-origin: bottom;
        }

        .bar::after {
            content: attr(data-value);
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .bar:hover::after {
            opacity: 1;
        }

        .bar.comparing {
            background: linear-gradient(135deg, var(--warning) 0%, #f9c052 100%);
            transform: scaleY(1.1);
            box-shadow: 0 6px 20px rgba(249, 168, 40, 0.4);
            z-index: 2;
        }

        .bar.swapping {
            background: linear-gradient(135deg, var(--error) 0%, #ff5e8a 100%);
            transform: scaleY(1.2) translateY(-10px);
            box-shadow: 0 8px 25px rgba(255, 56, 100, 0.4);
            z-index: 3;
            animation: swapAnimation 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes swapAnimation {
            0% { transform: scaleY(1) translateY(0); }
            50% { transform: scaleY(1.3) translateY(-30px); }
            100% { transform: scaleY(1.2) translateY(-10px); }
        }

        .bar.sorted {
            background: linear-gradient(135deg, var(--success) 0%, #1e7d5e 100%);
            box-shadow: 0 4px 15px rgba(44, 182, 125, 0.3);
        }

        .bar.pivot {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }

        .grid-container {
            display: grid;
            gap: 1px;
            background: var(--border);
            border-radius: 12px;
            overflow: hidden;
            margin: 2rem auto;
            max-width: 600px;
            max-height: 600px;
            aspect-ratio: 1;
            width: 100%;
            height: auto;
            padding: 10px;
            box-sizing: border-box;
        }

        .grid-cell {
            aspect-ratio: 1;
            background: var(--secondary);
            transition: all 0.3s ease;
            position: relative;
        }

        .grid-cell.wall {
            background: var(--primary);
        }

        .grid-cell.start {
            background: var(--success);
            box-shadow: inset 0 0 20px rgba(44, 182, 125, 0.5);
            animation: pulse 2s infinite;
        }

        .grid-cell.end {
            background: var(--error);
            box-shadow: inset 0 0 20px rgba(255, 56, 100, 0.5);
            animation: pulse 2s infinite;
        }

        .grid-cell.visited {
            background: var(--accent);
            animation: visitPulse 0.3s ease-out;
        }

        .grid-cell.path {
            background: var(--warning);
            animation: pathGlow 1.5s ease-out;
        }

        @keyframes visitPulse {
            0% { transform: scale(0.8); opacity: 0.5; background: var(--accent-light); }
            100% { transform: scale(1); opacity: 1; background: var(--accent); }
        }

        @keyframes pathGlow {
            0% { transform: scale(0.9); box-shadow: 0 0 0 rgba(249, 168, 40, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(249, 168, 40, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 10px rgba(249, 168, 40, 0.6); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .tree-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            height: 400px;
            overflow: auto;
            position: relative;
        }

        .tree-level {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            position: relative;
            justify-content: center;
        }

        .tree-node {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.875rem;
            position: relative;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 15px rgba(127, 90, 240, 0.3);
            z-index: 1;
        }

        .tree-node::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 20px;
            background: var(--accent);
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0.5;
        }

        .tree-node.visiting {
            background: linear-gradient(135deg, var(--warning) 0%, #f9c052 100%);
            transform: scale(1.3);
            box-shadow: 0 6px 20px rgba(249, 168, 40, 0.5);
            z-index: 2;
        }

        .tree-node.visited {
            background: linear-gradient(135deg, var(--success) 0%, #1e7d5e 100%);
            box-shadow: 0 4px 15px rgba(44, 182, 125, 0.3);
        }

        .description {
            position: absolute;
            bottom: 1.5rem;
            left: 1.5rem;
            right: 1.5rem;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(127, 90, 240, 0.2);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .theme-toggle {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            width: 44px;
            height: 24px;
            border-radius: 12px;
            background: var(--secondary);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            padding: 0 3px;
        }

        .theme-toggle::after {
            content: '';
            display: block;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            transition: all 0.3s ease;
        }

        [data-theme="light"] .theme-toggle::after {
            transform: translateX(20px);
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--success);
            opacity: 0;
            animation: confetti 3s ease-in-out;
            z-index: 10;
        }

        @keyframes confetti {
            0% { transform: translateY(0) rotate(0); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
                height: auto;
            }
            
            .sidebar {
                width: 100%;
                order: 2;
            }
            
            .main-content {
                order: 1;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
                gap: 1rem;
            }
            
            .sidebar, .header, .visualization-area {
                padding: 1rem;
                border-radius: 16px;
            }
            
            .tree-node {
                width: 40px;
                height: 40px;
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h2 class="section-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"></path>
                    </svg>
                    Algorithm Settings
                </h2>
                
                <div class="form-group">
                    <label for="category">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                            <polyline points="9 22 9 12 15 12 15 22"></polyline>
                        </svg>
                        Category
                    </label>
                    <select id="category">
                        <option value="sorting">Sorting Algorithms</option>
                        <option value="pathfinding">Pathfinding</option>
                        <option value="tree">Tree Traversal</option>
                        <option value="dp">Dynamic Programming</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="algorithm">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="4 17 10 11 4 5"></polyline>
                            <line x1="12" y1="19" x2="20" y2="19"></line>
                        </svg>
                        Algorithm
                    </label>
                    <select id="algorithm">
                        <option value="bubble">Bubble Sort</option>
                        <option value="merge">Merge Sort</option>
                        <option value="quick">Quick Sort</option>
                        <option value="insertion">Insertion Sort</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="size">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="4" y1="9" x2="20" y2="9"></line>
                            <line x1="4" y1="15" x2="20" y2="15"></line>
                            <line x1="10" y1="3" x2="8" y2="21"></line>
                            <line x1="16" y1="3" x2="14" y2="21"></line>
                        </svg>
                        Data Size
                    </label>
                    <div class="slider-container">
                        <input type="range" id="size" min="5" max="100" value="30">
                        <span class="slider-value" id="sizeValue">30</span>
                    </div>
                </div>

                <div class="form-group">
                    <label for="speed">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polyline points="12 6 12 12 16 14"></polyline>
                        </svg>
                        Animation Speed
                    </label>
                    <div class="slider-container">
                        <input type="range" id="speed" min="1" max="100" value="50">
                        <span class="slider-value" id="speedValue">50</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="4"></circle>
                        <line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line>
                        <line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line>
                        <line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line>
                        <line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line>
                        <line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>
                    </svg>
                    Controls
                </h2>
                <button class="btn btn-primary" id="generateBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
                        <polyline points="13 2 13 9 20 9"></polyline>
                    </svg>
                    Generate New Data
                </button>
                <button class="btn btn-primary" id="startBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                    Start Visualization
                </button>
                <button class="btn btn-secondary" id="pauseBtn" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                    Pause
                </button>
                <button class="btn btn-secondary" id="stepBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="4" y1="12" x2="20" y2="12"></line>
                        <polyline points="14 6 20 12 14 18"></polyline>
                    </svg>
                    Step Through
                </button>
                <button class="btn btn-secondary" id="resetBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M2.5 2v6h6M2.66 15.57a10 10 0 1 0 2.17-9.87M21.5 22v-6h-6"></path>
                    </svg>
                    Reset
                </button>
            </div>

            <div class="section">
                <h2 class="section-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="16" y1="13" x2="8" y2="13"></line>
                        <line x1="16" y1="17" x2="8" y2="17"></line>
                        <polyline points="10 9 9 9 8 9"></polyline>
                    </svg>
                    Algorithm Info
                </h2>
                <div class="complexity-badge" id="complexity">O(n²)</div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="comparisons">0</div>
                        <div class="stat-label">Comparisons</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="swaps">0</div>
                        <div class="stat-label">Array Access</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="4 17 10 11 4 5"></polyline>
                        <line x1="12" y1="19" x2="20" y2="19"></line>
                    </svg>
                    Pseudocode
                </h2>
                <div class="pseudocode" id="pseudocode">
for i = 0 to n-1:
    for j = 0 to n-i-2:
        if arr[j] > arr[j+1]:
            swap(arr[j], arr[j+1])
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="header fade-in">
                <h1>Algorithm Visualizer</h1>
                <p class="subtitle">Interactive visualization of classic computer science algorithms with modern animations</p>
            </div>

            <div class="visualization-area fade-in">
                <div id="sortingView" class="sorting-container"></div>
                <div id="gridView" class="grid-container" style="display: none;"></div>
                <div id="treeView" class="tree-container" style="display: none;"></div>
                <div class="description" id="description">
                    Select an algorithm and click "Start Visualization" to begin
                </div>
            </div>
        </div>
    </div>

    <div class="theme-toggle" id="themeToggle"></div>

    <script>
        class AlgorithmVisualizer {
            constructor() {
                    this.data = [];
                    this.isPlaying = false;
                    this.isPaused = false;
                    this.currentStep = 0;
                    this.animationSteps = [];
                    this.comparisons = 0;
                    this.arrayAccess = 0;
                    this.currentCategory = 'sorting';
                    this.currentAlgorithm = 'bubble';
                
                this.algorithms = {
                    sorting: {
                        bubble: { name: 'Bubble Sort', complexity: 'O(n²)' },
                        merge: { name: 'Merge Sort', complexity: 'O(n log n)' },
                        quick: { name: 'Quick Sort', complexity: 'O(n log n)' },
                        insertion: { name: 'Insertion Sort', complexity: 'O(n²)' }
                    },
                    pathfinding: {
                        dijkstra: { name: 'Dijkstra', complexity: 'O(V²)' },
                        astar: { name: 'A* Search', complexity: 'O(b^d)' }
                    },
                    tree: {
                        bfs: { name: 'Breadth-First Search', complexity: 'O(V + E)' },
                        dfs: { name: 'Depth-First Search', complexity: 'O(V + E)' }
                    },
                    dp: {
                        knapsack: { name: '0-1 Knapsack', complexity: 'O(nW)' },
                        lcs: { name: 'Longest Common Subsequence', complexity: 'O(mn)' }
                    }
                };

                this.pseudocodes = {
                    bubble: `for i = 0 to n-1:
    for j = 0 to n-i-2:
        if arr[j] > arr[j+1]:
            swap(arr[j], arr[j+1])`,
                    merge: `mergeSort(arr, l, r):
    if l < r:
        m = (l + r) / 2
        mergeSort(arr, l, m)
        mergeSort(arr, m+1, r)
        merge(arr, l, m, r)`,
                    quick: `quickSort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)`,
                    insertion: `for i = 1 to n-1:
    key = arr[i]
    j = i - 1
    while j >= 0 and arr[j] > key:
        arr[j+1] = arr[j]
        j = j - 1
    arr[j+1] = key`,
                    dijkstra: `dijkstra(graph, src):
    dist[src] = 0
    for each vertex v:
        if v != src: dist[v] = ∞
    Q = all vertices
    while Q is not empty:
        u = vertex in Q with min dist[u]
        remove u from Q
        for each neighbor v of u:
            alt = dist[u] + length(u, v)
            if alt < dist[v]:
                dist[v] = alt`,
                    astar: `astar(start, goal):
    openSet = {start}
    gScore[start] = 0
    fScore[start] = h(start, goal)
    
    while openSet is not empty:
        current = node with lowest fScore
        if current == goal:
            return path
        
        for each neighbor of current:
            tentative_gScore = gScore[current] + d(current, neighbor)
            if tentative_gScore < gScore[neighbor]:
                gScore[neighbor] = tentative_gScore
                fScore[neighbor] = gScore[neighbor] + h(neighbor, goal)`,
                    bfs: `bfs(graph, start):
    queue = [start]
    visited = {start}
    
    while queue is not empty:
        vertex = queue.dequeue()
        process(vertex)
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)`,
                    dfs: `dfs(graph, vertex, visited):
    visited.add(vertex)
    process(vertex)
    
    for neighbor in graph[vertex]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)`,
                    knapsack: `knapsack(W, wt, val, n):
    dp[0...n][0...W] = 0
    
    for i = 1 to n:
        for w = 1 to W:
            if wt[i-1] <= w:
                dp[i][w] = max(val[i-1] + dp[i-1][w-wt[i-1]], dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]`,
                    lcs: `lcs(X, Y, m, n):
    L[0...m][0...n]
    
    for i = 0 to m:
        for j = 0 to n:
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])`
                };

                    this.initializeEventListeners();
                    this.updateAlgorithmOptions();
                    this.switchVisualizationView();
            }

            initializeEventListeners() {
                document.getElementById('category').addEventListener('change', () => {
                    this.currentCategory = document.getElementById('category').value;
                    this.updateAlgorithmOptions();
                });

                document.getElementById('algorithm').addEventListener('change', () => {
                    this.currentAlgorithm = document.getElementById('algorithm').value;
                    this.updateUI();
                });

                document.getElementById('size').addEventListener('input', (e) => {
                    document.getElementById('sizeValue').textContent = e.target.value;
                    if (!this.isPlaying) this.generateData();
                });

                document.getElementById('speed').addEventListener('input', (e) => {
                    document.getElementById('speedValue').textContent = e.target.value;
                });

                document.getElementById('generateBtn').addEventListener('click', () => {
                    this.generateData();
                    
                    // For sorting, ensure the view is properly displayed
                    if (this.currentCategory === 'sorting') {
                        document.getElementById('sortingView').style.display = 'flex';
                        document.getElementById('gridView').style.display = 'none';
                        document.getElementById('treeView').style.display = 'none';
                    }
                });

                document.getElementById('startBtn').addEventListener('click', () => this.startVisualization());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pauseVisualization());
                document.getElementById('stepBtn').addEventListener('click', () => this.stepThrough());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());

                document.getElementById('themeToggle').addEventListener('click', () => {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    document.documentElement.setAttribute('data-theme', newTheme);
                });
            }

            updateAlgorithmOptions() {
                const algorithmSelect = document.getElementById('algorithm');
                const algorithms = this.algorithms[this.currentCategory];
                
                algorithmSelect.innerHTML = '';
                Object.keys(algorithms).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = algorithms[key].name;
                    algorithmSelect.appendChild(option);
                });

                this.currentAlgorithm = Object.keys(algorithms)[0];
                this.updateUI();
                this.switchVisualizationView();
            }

            switchVisualizationView() {
                const views = ['sortingView', 'gridView', 'treeView'];
                views.forEach(view => {
                    document.getElementById(view).style.display = 'none';
                });

                switch(this.currentCategory) {
                    case 'sorting':
                        document.getElementById('sortingView').style.display = 'flex';
                        this.generateData(); // This will generate and render the bars
                        break;
                    case 'pathfinding':
                        document.getElementById('gridView').style.display = 'grid';
                        this.generateGrid();
                        break;
                    case 'tree':
                        document.getElementById('treeView').style.display = 'flex';
                        this.generateTree();
                        break;
                    case 'dp':
                        document.getElementById('sortingView').style.display = 'flex';
                        this.generateDPVisualization();
                        break;
                }
            }

            updateUI() {
                const algorithm = this.algorithms[this.currentCategory][this.currentAlgorithm];
                document.getElementById('complexity').textContent = algorithm.complexity;
                document.getElementById('pseudocode').textContent = this.pseudocodes[this.currentAlgorithm] || 'Pseudocode not available';
            }

            generateData() {
                const size = parseInt(document.getElementById('size').value);
                this.comparisons = 0;
                this.arrayAccess = 0;
                this.updateStats();
                
                // Clear any existing visualization
                this.animationSteps = [];
                this.currentStep = 0;
                
                switch(this.currentCategory) {
                    case 'sorting':
                        this.data = Array.from({length: size}, () => Math.floor(Math.random() * 300) + 10);
                        document.getElementById('sortingView').style.display = 'flex';
                        this.renderBars();
                        break;
                    case 'pathfinding':
                        document.getElementById('gridView').style.display = 'grid';
                        this.generateGrid();
                        break;
                    case 'tree':
                        document.getElementById('treeView').style.display = 'flex';
                        this.generateTree();
                        break;
                    case 'dp':
                        document.getElementById('sortingView').style.display = 'flex';
                        this.generateDPVisualization();
                        break;
                }
            }

            generateGrid() {
                const gridView = document.getElementById('gridView');
                const gridSize = 20;
                gridView.innerHTML = '';
                gridView.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                
                for (let i = 0; i < gridSize * gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.index = i;
                    
                    // Add some random walls
                    if (Math.random() < 0.3 && i !== 0 && i !== gridSize * gridSize - 1) {
                        cell.classList.add('wall');
                    }
                    
                    gridView.appendChild(cell);
                }
                
                // Set start and end points
                gridView.children[0].classList.add('start');
                gridView.children[gridSize * gridSize - 1].classList.add('end');
            }

			generateTree() {
				const treeView = document.getElementById('treeView');
				treeView.innerHTML = '';
				
				const size = Math.min(15, parseInt(document.getElementById('size').value));
				const levels = Math.min(4, Math.max(1, Math.floor(Math.log2(size)) + 1));
				
				// Generate tree nodes with proper structure
				let nodes = [];
				let nodeCount = 0;
				
				for (let level = 0; level < levels; level++) {
					const levelDiv = document.createElement('div');
					levelDiv.className = 'tree-level';
					
					const nodesInLevel = Math.pow(2, level);
					for (let i = 0; i < nodesInLevel && nodeCount < size; i++) {
						const node = document.createElement('div');
						node.className = 'tree-node';
						const value = Math.floor(Math.random() * 100) + 1;
						node.textContent = value;
						node.dataset.value = value;
						node.dataset.index = nodeCount;
						node.dataset.level = level;
						node.dataset.position = i;
						
						// Set parent index if not root
						if (level > 0) {
							const parentIndex = Math.floor(i / 2);
							node.dataset.parent = nodes[level-1][parentIndex].dataset.index;
						}
						
						levelDiv.appendChild(node);
						nodeCount++;
					}
					
					treeView.appendChild(levelDiv);
					nodes.push(Array.from(levelDiv.children));
				}
			}

            // Helper method to generate a random binary tree
            generateRandomBinaryTree(levels) {
                const tree = [];
                let currentValue = 1;
                
                for (let i = 0; i < levels; i++) {
                    const level = [];
                    const nodesInLevel = Math.pow(2, i);
                    
                    for (let j = 0; j < nodesInLevel; j++) {
                        // Randomly decide to create a node or leave it empty (for more interesting trees)
                        if (Math.random() > 0.3 || i === 0) { // Always create root node
                            const value = Math.floor(Math.random() * 50) + 1;
                            level.push({ value });
                            currentValue++;
                        } else {
                            level.push(null);
                        }
                    }
                    
                    tree.push(level);
                }
                
                return tree;
            }

            generateDPVisualization() {
                const container = document.getElementById('sortingView');
                container.innerHTML = '';
                container.style.flexDirection = 'column';
                container.style.alignItems = 'center';
                
                const size = parseInt(document.getElementById('size').value);
                const rows = Math.min(8, Math.max(1, Math.floor(Math.sqrt(size))));
                const cols = Math.min(8, Math.max(1, Math.ceil(size / rows)));
                
                const title = document.createElement('h3');
                title.textContent = `${this.algorithms[this.currentCategory][this.currentAlgorithm].name} Visualization`;
                title.style.color = 'var(--accent)';
                title.style.marginBottom = '2rem';
                container.appendChild(title);
                
                const table = document.createElement('div');
                table.style.display = 'grid';
                table.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                table.style.gap = '4px';
                table.style.maxWidth = '400px';
                
                for (let i = 0; i < rows * cols; i++) {
                    const cell = document.createElement('div');
                    cell.style.width = '40px';
                    cell.style.height = '40px';
                    cell.style.background = 'var(--secondary)';
                    cell.style.border = '1px solid var(--border)';
                    cell.style.borderRadius = '4px';
                    cell.style.display = 'flex';
                    cell.style.alignItems = 'center';
                    cell.style.justifyContent = 'center';
                    cell.style.fontSize = '0.75rem';
                    cell.style.color = 'var(--text)';
                    cell.style.transition = 'all 0.3s ease';
                    cell.textContent = Math.floor(Math.random() * 10);
                    cell.dataset.index = i;
                    table.appendChild(cell);
                }
                
                container.appendChild(table);
            }

            renderBars() {
                const container = document.getElementById('sortingView');
                container.innerHTML = ''; // Clear existing bars
                container.style.flexDirection = 'row';
                container.style.alignItems = 'end';
                
                if (this.data.length === 0) return;
                
                const maxHeight = Math.max(...this.data);
                const containerWidth = container.clientWidth || 800;
                const barWidth = Math.max(8, (containerWidth - (this.data.length * 4)) / this.data.length);
                
                this.data.forEach((value, index) => {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.width = `${barWidth}px`;
                    bar.style.height = `${(value / maxHeight) * 350}px`;
                    bar.dataset.index = index;
                    bar.dataset.value = value;
                    container.appendChild(bar);
                });
            }

            updateStats() {
                document.getElementById('comparisons').textContent = this.comparisons;
                document.getElementById('swaps').textContent = this.arrayAccess;
            }

				startVisualization() {
					if (this.isPaused) {
						this.isPaused = false;
						this.continueAnimation();
						return;
					}

					this.isPlaying = true;
					this.currentStep = 0;
					this.comparisons = 0;
					this.arrayAccess = 0;
					
					// Disable appropriate buttons
					document.getElementById('startBtn').disabled = true;
					document.getElementById('pauseBtn').disabled = false;
					document.getElementById('generateBtn').disabled = true;
					document.getElementById('stepBtn').disabled = true;
                
                switch(this.currentCategory) {
                    case 'sorting':
                        this.startSortingVisualization();
                        break;
                    case 'pathfinding':
                        this.startPathfindingVisualization();
                        break;
                    case 'tree':
                        this.startTreeVisualization();
                        break;
                    case 'dp':
                        this.startDPVisualization();
                        break;
                }
            }

            pauseVisualization() {
                this.isPaused = true;
                this.isPlaying = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
            }

			reset() {
				this.isPlaying = false;
				this.isPaused = false;
				this.currentStep = 0;
				this.animationSteps = [];
				
				// Re-enable all buttons
				document.getElementById('startBtn').disabled = false;
				document.getElementById('pauseBtn').disabled = true;
				document.getElementById('generateBtn').disabled = false;
				document.getElementById('stepBtn').disabled = false;
				
				// Reset the visualization
				switch(this.currentCategory) {
					case 'sorting':
						this.renderBars(); // Just re-render the existing data
						break;
					case 'pathfinding':
						this.generateGrid();
						break;
					case 'tree':
						this.generateTree();
						break;
					case 'dp':
						this.generateDPVisualization();
						break;
				}
				
				document.getElementById('description').textContent = 'Select an algorithm and click "Start Visualization" to begin';
			}

            stepThrough() {
                if (this.animationSteps.length === 0) {
                    this.generateAnimationSteps();
                }
                
                if (this.currentStep < this.animationSteps.length) {
                    this.executeStep(this.animationSteps[this.currentStep]);
                    this.currentStep++;
                }
            }

            // Sorting Algorithms
            startSortingVisualization() {
                this.generateAnimationSteps();
                this.currentStep = 0;
                this.continueAnimation();
            }

            generateAnimationSteps() {
                this.animationSteps = [];
                const dataCopy = [...this.data];
                
                switch(this.currentAlgorithm) {
                    case 'bubble':
                        this.generateBubbleSortSteps(dataCopy);
                        break;
                    case 'merge':
                        this.generateMergeSortSteps(dataCopy, 0, dataCopy.length - 1);
                        break;
                    case 'quick':
                        this.generateQuickSortSteps(dataCopy, 0, dataCopy.length - 1);
                        break;
                    case 'insertion':
                        this.generateInsertionSortSteps(dataCopy);
                        break;
                }
            }

            generateBubbleSortSteps(arr) {
                const n = arr.length;
                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        this.animationSteps.push({
                            type: 'compare',
                            indices: [j, j + 1],
                            description: `Comparing elements at positions ${j} and ${j + 1}`,
                            data: [...arr]
                        });
                        
                        if (arr[j] > arr[j + 1]) {
                            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                            this.animationSteps.push({
                                type: 'swap',
                                indices: [j, j + 1],
                                description: `Swapping elements at positions ${j} and ${j + 1}`,
                                data: [...arr]
                            });
                        }
                    }
                    
                    this.animationSteps.push({
                        type: 'sorted',
                        indices: [n - i - 1],
                        description: `Element at position ${n - i - 1} is now in its final position`,
                        data: [...arr]
                    });
                }
                
                this.animationSteps.push({
                    type: 'complete',
                    indices: [],
                    description: 'Sorting complete!',
                    data: [...arr]
                });
            }

            generateInsertionSortSteps(arr) {
                for (let i = 1; i < arr.length; i++) {
                    let key = arr[i];
                    let j = i - 1;
                    
                    this.animationSteps.push({
                        type: 'select',
                        indices: [i],
                        description: `Selecting element ${key} at position ${i}`,
                        data: [...arr]
                    });
                    
                    while (j >= 0 && arr[j] > key) {
                        this.animationSteps.push({
                            type: 'compare',
                            indices: [j, j + 1],
                            description: `Comparing ${arr[j]} with ${key}`,
                            data: [...arr]
                        });
                        
                        arr[j + 1] = arr[j];
                        this.animationSteps.push({
                            type: 'shift',
                            indices: [j, j + 1],
                            description: `Shifting ${arr[j]} to the right`,
                            data: [...arr]
                        });
                        j = j - 1;
                    }
                    
                    arr[j + 1] = key;
                    this.animationSteps.push({
                        type: 'insert',
                        indices: [j + 1],
                        description: `Inserting ${key} at position ${j + 1}`,
                        data: [...arr]
                    });
                }
                
                this.animationSteps.push({
                    type: 'complete',
                    indices: [],
                    description: 'Sorting complete!',
                    data: [...arr]
                });
            }

            generateQuickSortSteps(arr, low, high) {
                if (low < high) {
                    const pi = this.partitionForSteps(arr, low, high);
                    this.generateQuickSortSteps(arr, low, pi - 1);
                    this.generateQuickSortSteps(arr, pi + 1, high);
                }
            }

            partitionForSteps(arr, low, high) {
                const pivot = arr[high];
                let i = low - 1;
                
                this.animationSteps.push({
                    type: 'pivot',
                    indices: [high],
                    description: `Selecting pivot: ${pivot}`,
                    data: [...arr]
                });
                
                for (let j = low; j <= high - 1; j++) {
                    this.animationSteps.push({
                        type: 'compare',
                        indices: [j, high],
                        description: `Comparing ${arr[j]} with pivot ${pivot}`,
                        data: [...arr]
                    });
                    
                    if (arr[j] < pivot) {
                        i++;
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        this.animationSteps.push({
                            type: 'swap',
                            indices: [i, j],
                            description: `Swapping ${arr[j]} with ${arr[i]}`,
                            data: [...arr]
                        });
                    }
                }
                
                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                this.animationSteps.push({
                    type: 'pivot_place',
                    indices: [i + 1, high],
                    description: `Placing pivot at its correct position`,
                    data: [...arr]
                });
                
                return i + 1;
            }

            generateMergeSortSteps(arr, left, right) {
                if (left >= right) return;
                
                const mid = Math.floor((left + right) / 2);
                this.generateMergeSortSteps(arr, left, mid);
                this.generateMergeSortSteps(arr, mid + 1, right);
                this.mergeForSteps(arr, left, mid, right);
            }

            mergeForSteps(arr, left, mid, right) {
                const leftArr = arr.slice(left, mid + 1);
                const rightArr = arr.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                this.animationSteps.push({
                    type: 'merge_start',
                    indices: Array.from({length: right - left + 1}, (_, idx) => left + idx),
                    description: `Merging subarrays [${left}...${mid}] and [${mid + 1}...${right}]`,
                    data: [...arr]
                });
                
                while (i < leftArr.length && j < rightArr.length) {
                    this.animationSteps.push({
                        type: 'compare',
                        indices: [left + i, mid + 1 + j],
                        description: `Comparing ${leftArr[i]} and ${rightArr[j]}`,
                        data: [...arr]
                    });
                    
                    if (leftArr[i] <= rightArr[j]) {
                        arr[k] = leftArr[i];
                        i++;
                    } else {
                        arr[k] = rightArr[j];
                        j++;
                    }
                    
                    this.animationSteps.push({
                        type: 'merge_place',
                        indices: [k],
                        description: `Placing ${arr[k]} at position ${k}`,
                        data: [...arr]
                    });
                    k++;
                }
                
                while (i < leftArr.length) {
                    arr[k] = leftArr[i];
                    this.animationSteps.push({
                        type: 'merge_place',
                        indices: [k],
                        description: `Copying remaining element ${arr[k]}`,
                        data: [...arr]
                    });
                    i++;
                    k++;
                }
                
                while (j < rightArr.length) {
                    arr[k] = rightArr[j];
                    this.animationSteps.push({
                        type: 'merge_place',
                        indices: [k],
                        description: `Copying remaining element ${arr[k]}`,
                        data: [...arr]
                    });
                    j++;
                    k++;
                }
            }

            continueAnimation() {
                if (!this.isPlaying || this.isPaused) return;
                
                if (this.currentStep < this.animationSteps.length) {
                    this.executeStep(this.animationSteps[this.currentStep]);
                    this.currentStep++;
                    
                    const speed = parseInt(document.getElementById('speed').value);
                    const delay = Math.max(50, 500 - (speed * 4));
                    
                    setTimeout(() => this.continueAnimation(), delay);
                } else {
                    this.isPlaying = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('pauseBtn').disabled = true;
                    document.getElementById('generateBtn').disabled = false;
                    this.createConfetti();
                }
            }

            executeStep(step) {
                this.data = [...step.data];
                this.renderBars();
                
                const bars = document.querySelectorAll('.bar');
                
                // Reset all bar styles
                bars.forEach(bar => {
                    bar.className = 'bar';
                });
                
                // Apply step-specific styling
                step.indices.forEach(index => {
                    if (bars[index]) {
                        switch(step.type) {
                            case 'compare':
                                bars[index].classList.add('comparing');
                                break;
                            case 'swap':
                            case 'shift':
                                bars[index].classList.add('swapping');
                                break;
                            case 'sorted':
                            case 'complete':
                                bars[index].classList.add('sorted');
                                break;
                            case 'pivot':
                                bars[index].classList.add('pivot');
                                break;
                        }
                    }
                });
                
                if (step.type === 'complete') {
                    bars.forEach(bar => bar.classList.add('sorted'));
                }
                
                // Update statistics
                if (['compare', 'swap', 'shift'].includes(step.type)) {
                    this.comparisons++;
                    this.arrayAccess += 2;
                }
                
                this.updateStats();
                document.getElementById('description').textContent = step.description;
            }

            // Pathfinding Algorithms
            async startPathfindingVisualization() {
                const cells = document.querySelectorAll('.grid-cell');
                const startCell = document.querySelector('.grid-cell.start');
                const endCell = document.querySelector('.grid-cell.end');
                
                if (this.currentAlgorithm === 'dijkstra') {
                    await this.visualizeDijkstra(startCell, endCell, cells);
                } else if (this.currentAlgorithm === 'astar') {
                    await this.visualizeAStar(startCell, endCell, cells);
                }
                
                this.createConfetti();
            }

            async visualizeDijkstra(startCell, endCell, cells) {
                const visited = new Set();
                const distances = new Map();
                const previous = new Map();
                const unvisited = new Set();
                
                // Initialize distances
                cells.forEach(cell => {
                    distances.set(cell.dataset.index, Infinity);
                    unvisited.add(cell.dataset.index);
                });
                distances.set(startCell.dataset.index, 0);
                
                while (unvisited.size > 0 && this.isPlaying) {
                    // Find unvisited node with minimum distance
                    let current = null;
                    let minDistance = Infinity;
                    
                    for (let nodeIndex of unvisited) {
                        if (distances.get(nodeIndex) < minDistance) {
                            minDistance = distances.get(nodeIndex);
                            current = nodeIndex;
                        }
                    }
                    
                    if (!current || minDistance === Infinity) break;
                    
                    unvisited.delete(current);
                    visited.add(current);
                    
                    const currentCell = cells[parseInt(current)];
                    if (!currentCell.classList.contains('start') && !currentCell.classList.contains('end')) {
                        currentCell.classList.add('visited');
                        await this.sleep(100 - parseInt(document.getElementById('speed').value));
                    }
                    
                    if (current === endCell.dataset.index) {
                        await this.reconstructPath(previous, endCell.dataset.index, cells);
                        document.getElementById('description').textContent = 'Path found!';
                        break;
                    }
                    
                    // Check neighbors
                    const neighbors = this.getNeighbors(parseInt(current), 20);
                    for (let neighbor of neighbors) {
                        if (cells[neighbor].classList.contains('wall') || visited.has(neighbor.toString())) continue;
                        
                        const alt = distances.get(current) + 1;
                        if (alt < distances.get(neighbor.toString())) {
                            distances.set(neighbor.toString(), alt);
                            previous.set(neighbor.toString(), current);
                        }
                    }
                    
                    document.getElementById('description').textContent = `Exploring node ${current}...`;
                }
            }

            async visualizeAStar(startCell, endCell, cells) {
                const openSet = [parseInt(startCell.dataset.index)];
                const closedSet = new Set();
                const gScore = new Map();
                const fScore = new Map();
                const previous = new Map();
                
                gScore.set(startCell.dataset.index, 0);
                fScore.set(startCell.dataset.index, this.heuristic(parseInt(startCell.dataset.index), parseInt(endCell.dataset.index), 20));
                
                while (openSet.length > 0 && this.isPlaying) {
                    // Find node with lowest fScore
                    let current = openSet.reduce((lowest, node) => {
                        return (fScore.get(node.toString()) || Infinity) < (fScore.get(lowest.toString()) || Infinity) ? node : lowest;
                    });
                    
                    if (current === parseInt(endCell.dataset.index)) {
                        await this.reconstructPath(previous, endCell.dataset.index, cells);
                        document.getElementById('description').textContent = 'Path found with A*!';
                        break;
                    }
                    
                    openSet.splice(openSet.indexOf(current), 1);
                    closedSet.add(current);
                    
                    const currentCell = cells[current];
                    if (!currentCell.classList.contains('start') && !currentCell.classList.contains('end')) {
                        currentCell.classList.add('visited');
                        await this.sleep(100 - parseInt(document.getElementById('speed').value));
                    }
                    
                    const neighbors = this.getNeighbors(current, 20);
                    for (let neighbor of neighbors) {
                        if (cells[neighbor].classList.contains('wall') || closedSet.has(neighbor)) continue;
                        
                        const tentativeGScore = (gScore.get(current.toString()) || 0) + 1;
                        
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        } else if (tentativeGScore >= (gScore.get(neighbor.toString()) || Infinity)) {
                            continue;
                        }
                        
                        previous.set(neighbor.toString(), current.toString());
                        gScore.set(neighbor.toString(), tentativeGScore);
                        fScore.set(neighbor.toString(), tentativeGScore + this.heuristic(neighbor, parseInt(endCell.dataset.index), 20));
                    }
                    
                    document.getElementById('description').textContent = `A* exploring node ${current}...`;
                }
            }

            getNeighbors(index, gridSize) {
                const neighbors = [];
                const row = Math.floor(index / gridSize);
                const col = index % gridSize;
                
                // Up, Down, Left, Right
                if (row > 0) neighbors.push((row - 1) * gridSize + col);
                if (row < gridSize - 1) neighbors.push((row + 1) * gridSize + col);
                if (col > 0) neighbors.push(row * gridSize + (col - 1));
                if (col < gridSize - 1) neighbors.push(row * gridSize + (col + 1));
                
                return neighbors;
            }

            heuristic(a, b, gridSize) {
                const aRow = Math.floor(a / gridSize);
                const aCol = a % gridSize;
                const bRow = Math.floor(b / gridSize);
                const bCol = b % gridSize;
                
                return Math.abs(aRow - bRow) + Math.abs(aCol - bCol);
            }

            async reconstructPath(previous, current, cells) {
                const path = [];
                while (previous.has(current)) {
                    path.unshift(current);
                    current = previous.get(current);
                }
                
                for (let nodeIndex of path) {
                    const cell = cells[parseInt(nodeIndex)];
                    if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                        cell.classList.add('path');
                        await this.sleep(50);
                    }
                }
            }

            // Tree Traversal Algorithms
            async startTreeVisualization() {
                const nodes = document.querySelectorAll('.tree-node');
                
                if (this.currentAlgorithm === 'bfs') {
                    await this.visualizeBFS(nodes);
                } else if (this.currentAlgorithm === 'dfs') {
                    await this.visualizeDFS(nodes);
                }
                
                this.createConfetti();
            }

			async visualizeBFS(nodes) {
				const allNodes = document.querySelectorAll('.tree-node');
				if (allNodes.length === 0) return;
				
				// Reset all nodes first
				allNodes.forEach(node => {
					node.classList.remove('visiting', 'visited');
				});
				
				const queue = [allNodes[0]]; // Start with root node
				const visited = new Set();
				
				document.getElementById('description').textContent = 'Starting Breadth-First Search...';
				
				while (queue.length > 0 && this.isPlaying) {
					const current = queue.shift();
					if (visited.has(current)) continue;
					
					visited.add(current);
					current.classList.add('visiting');
					
					document.getElementById('description').textContent = `Visiting node ${current.textContent}`;
					await this.sleep(200 - parseInt(document.getElementById('speed').value));
					
					current.classList.remove('visiting');
					current.classList.add('visited');
					
					// Find children
					const currentIndex = current.dataset.index;
					const children = Array.from(allNodes).filter(node => 
						node.dataset.parent === currentIndex && !visited.has(node)
					);
					
					children.forEach(child => queue.push(child));
					
					await this.sleep(100);
				}
				
				document.getElementById('description').textContent = 'BFS traversal complete!';
			}

			async visualizeDFS(nodes) {
				const allNodes = document.querySelectorAll('.tree-node');
				if (allNodes.length === 0) return;
				
				// Reset all nodes first
				allNodes.forEach(node => {
					node.classList.remove('visiting', 'visited');
				});
				
				document.getElementById('description').textContent = 'Starting Depth-First Search...';
				await this.dfsRecursive(allNodes[0], allNodes);
				document.getElementById('description').textContent = 'DFS traversal complete!';
			}

			async dfsRecursive(node, allNodes, visited = new Set()) {
				if (!this.isPlaying || visited.has(node)) return;
				
				visited.add(node);
				node.classList.add('visiting');
				
				document.getElementById('description').textContent = `Visiting node ${node.textContent}`;
				await this.sleep(200 - parseInt(document.getElementById('speed').value));
				
				node.classList.remove('visiting');
				node.classList.add('visited');
				
				// Find children
				const children = Array.from(allNodes).filter(n => 
					n.dataset.parent === node.dataset.index && !visited.has(n)
				);
				
				for (const child of children) {
					await this.dfsRecursive(child, allNodes, visited);
				}
				
				await this.sleep(100);
			}

            isChild(parent, child) {
                // Simple rule for binary tree structure
                return (child < parent && (child * 2 === parent || child * 2 + 1 === parent)) ||
                       (child > parent && (parent * 2 === child || parent * 2 + 1 === child));
            }

            // Dynamic Programming Algorithms
            async startDPVisualization() {
                const cells = document.querySelectorAll('#sortingView > div > div');
                
                if (this.currentAlgorithm === 'knapsack') {
                    await this.visualizeKnapsack(cells);
                } else if (this.currentAlgorithm === 'lcs') {
                    await this.visualizeLCS(cells);
                }
                
                this.createConfetti();
            }

            async visualizeKnapsack(cells) {
                document.getElementById('description').textContent = 'Solving 0-1 Knapsack Problem...';
                
                // Simulate knapsack DP table filling
                for (let i = 0; i < cells.length && this.isPlaying; i++) {
                    cells[i].style.background = 'var(--accent)';
                    cells[i].textContent = Math.floor(Math.random() * 10);
                    
                    document.getElementById('description').textContent = `Computing DP[${Math.floor(i/8)}][${i%8}]`;
                    await this.sleep(200 - parseInt(document.getElementById('speed').value));
                    
                    cells[i].style.background = 'var(--success)';
                    await this.sleep(50);
                }
                
                document.getElementById('description').textContent = 'Knapsack problem solved!';
            }

            async visualizeLCS(cells) {
                document.getElementById('description').textContent = 'Finding Longest Common Subsequence...';
                
                // Simulate LCS DP table filling
                for (let i = 0; i < cells.length && this.isPlaying; i++) {
                    cells[i].style.background = 'var(--accent)';
                    cells[i].textContent = Math.floor(Math.random() * 5);
                    
                    document.getElementById('description').textContent = `Computing LCS[${Math.floor(i/8)}][${i%8}]`;
                    await this.sleep(200 - parseInt(document.getElementById('speed').value));
                    
                    cells[i].style.background = 'var(--success)';
                    await this.sleep(50);
                }
                
                document.getElementById('description').textContent = 'LCS computation complete!';
            }

            createConfetti() {
                const visualizationArea = document.querySelector('.visualization-area');
                const colors = ['var(--accent)', 'var(--success)', 'var(--warning)', 'var(--error)'];
                
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = `${Math.random() * 100}%`;
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                    confetti.style.width = `${Math.random() * 8 + 4}px`;
                    confetti.style.height = `${Math.random() * 8 + 4}px`;
                    visualizationArea.appendChild(confetti);
                    
                    // Remove confetti after animation
                    setTimeout(() => {
                        confetti.remove();
                    }, 3000);
                }
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AlgorithmVisualizer();
        });
    </script>
</body>
</html>